#!/usr/bin/perl
# Copyright (c) 2013  Joerg Pernfuss <code.jpe@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# nsr - name service resolver
#
# Very simple name to ip resolver. Behaves similar to host(1), but since it
# uses the regular system resolver(3), you can manipulate its results via
# nsswitch.conf(5).
#
use strict;
use 5.014_000;
use feature qw/:5.14/;
BEGIN {
  use Socket qw/getaddrinfo getnameinfo NI_NUMERICHOST
                SOCK_RAW AI_CANONNAME AF_INET AF_INET6/;
  use subs qw/reverse_ipv4 reverse_ipv6 is_ipaddress/;
  use constant {
    EX_OK    => 0,
    EX_ERROR => 1,
    EX_USAGE => 64,
    TRUE     => 1,
    FALSE    => 0,
  };
}
$0 = q/nsr/;
my ( $name, $canon, $t_name, $t_alias ) = ( undef, undef, undef, undef );
unless ( $ARGV[0] ) {
  say STDERR "No hostname, no lookup.";
  exit EX_USAGE;
}
$name = $ARGV[0];
my $is_ipaddress = is_ipaddress ( $name );

# use gethostbyname() since getaddrinfo() does not indicate if it
# followed a CNAME. If we followed a CNAME, update what we actually
# query
( $t_name, $t_alias, undef, undef, undef ) = gethostbyname( $name );
if (   ( $t_alias         )
    && ( $name ne $t_name )) {
  say "$t_alias is an alias for $t_name";
  $name = $t_name;
}

my ( $err, @res ) = getaddrinfo ( $name, "", { socktype => SOCK_RAW,
                                               flags    => AI_CANONNAME } );
if ( $err ) {
  say STDERR "Host $name not found: NXDOMAIN/SERVFAIL";
  exit EX_ERROR;
}

while ( my $ai = shift @res ) {
  if ( $is_ipaddress ) {
    my ( $reverse, $tld ) = ( undef, undef );
    my ( $err, $ptr_name ) = getnameinfo ( $ai->{addr} );
    given ( $ai->{family} ) {
      when ( AF_INET ) {
        $reverse = reverse_ipv4( $name );
        $tld = q/in-addr.arpa/;
      }
      when ( AF_INET6 ) {
        $reverse = reverse_ipv6( $name );
        $tld = q/ip6.arpa/;
      }
      default {
        say STDERR "Unrecognized IP protocol version.";
        exit EX_ERROR;
      }
    }
    if ( $name ne $ptr_name ) {
      say "$reverse.$tld domain name pointer $ptr_name.";
    }
    else {
      say "Host $reverse.$tld not found: NXDOMAIN/SERVFAIL";
      exit EX_ERROR;
    }
  }
  else {
    my ( $family ) = ( undef );
    my ( $err, $ipaddr ) = getnameinfo ( $ai->{addr}, NI_NUMERICHOST );

    # first result should have canonname set, after which we are good.
    # If things go shitfaced, fallback to $name
    $canon = $ai->{canonname} if $ai->{canonname};
    $canon = $canon // $name;

    given ( $ai->{family} ) {
      when ( AF_INET ) {
        $family = q/IPv4/;
      }
      when ( AF_INET6 ) {
        $family = q/IPv6/;
      }
      default {
        say STDERR "Unrecognized IP protocol version.";
        exit EX_ERROR;
      }
    }
    say "$canon has $family address $ipaddr";
  }
}
exit EX_OK;

sub reverse_ipv4 {
  my $ip4addr = shift;
  return join ( q/./, reverse split ( q/\./, $ip4addr ) );
}

sub reverse_ipv6 {
  # convert IPv6 address into fully expanded notation,
  # then reverse the order. This here only works for hexadecimal
  # notation with colons, not every valid IPv6 format
  my $ip6addr = shift;
  my @groups = split ( q/:/, $ip6addr );
  my @expanded;

  # Account for the various number of empty entries in @groups
  # depending on where in the address the :: was.
  # Hic sunt dracones.
  my $zeroblocks = 8 - scalar @groups;
  my $i = 0;
  if ( $ip6addr =~ /^::/ ) {
    $zeroblocks += 2;
  }
  elsif ( $ip6addr =~ /::/ ) {
    ++$zeroblocks;
  }

  foreach ( @groups ) {
    unless ( $_ eq "" ) {
      push ( @expanded, sprintf ( "%04s", lc ( $_ ) ) ) and next;
    }
    for ( $i; $i < $zeroblocks; $i++ ) {
      push ( @expanded, q/0000/ ) and next;
    }
  }
  # fill trailing zero blocks if the address ended in :: or is ::
  for ( my $j = scalar @expanded; $j < 8; $j++ ) {
    push ( @expanded, q/0000/ ) and next;
  }
  return join ( q/./, reverse split ( q//, join ( q//, @expanded ) ) );
}

sub is_ipaddress {
  my $input = shift;
  # contains illegal characters
  return FALSE unless ( $input =~ m/^[0-9a-f:\.]+$/i );

  # test if IPv4 address
  my $re4p = q'(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]{1,2})';
  my $re4 = qr/^$re4p(?:\.$re4p){3}$/;
  return TRUE if ( $input =~ $re4 );

  # test if IPv6 address
  # this only detects IPv6 addresses in hexadecimal format with
  # colons, the probably most common usecase. Valid formats where
  # the last 32-bit are written in "IPv4 notation" are not supported
  return TRUE if ( $input =~ m/^::$/ );
  my $short = FALSE;
  if ( $input =~ m/(?<!:)::$/ ) { # look-behind
    $input =~ s/::$//;
    $short = TRUE;
  }
  elsif ( $input =~ m/^::(?!:)/ ) { # look-ahead
    $input =~ s/^:://;
    $short = TRUE;
  }
  elsif ( $input =~ m/(?<!:)::(?!:)/ ) { # look-around
    $input =~ s/::/:/;
    $short = TRUE;
  }
  # input had :: twice or :::
  return FALSE if ($input =~ m/::/);

  my $re6p = q'(?:[0-9a-f]{1,4})';
  my $re6 = ( $short == TRUE )
          ? qr/^$re6p(?::$re6p){0,6}$/i
          : qr/^$re6p(?::$re6p){7}$/i;
  return TRUE if ( $input =~ $re6 );
  # did not conform to our narrow view of what an IPv4 or IPv6
  # address looks like -- might still be one!
  return FALSE;
}
