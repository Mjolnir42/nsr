#!/usr/bin/perl
# Copyright (c) 2013-2014  Joerg Pernfuss <code.jpe@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# nsr - name service resolver
#
# Very simple name to ip resolver. Behaves similar to host(1), but since it
# uses the regular system resolver(3), you can manipulate its results via
# nsswitch.conf(5).
#
use 5.014_000;
use perl5i::2;
BEGIN {
  use Socket qw/getaddrinfo getnameinfo NI_NUMERICHOST
                SOCK_RAW AI_CANONNAME AF_INET AF_INET6/;
  use Nsr::Util qw/reverse_ipv4 reverse_ipv6 is_ipaddress/;
  use constant {
    EX_OK    => 0,
    EX_ERROR => 1,
    EX_USAGE => 64,
    TRUE     => 1,
    FALSE    => 0,
  };
}
local $0 = q/nsr/;
my ( $name, $canon, $t_name, $t_alias ) = ( undef, undef, undef, undef );
unless ( $ARGV[0] ) {
  warn qq{No hostname, no lookup.\n};
  exit EX_USAGE;
}
$name = $ARGV[0];
my $is_ipaddress = is_ipaddress ( $name );

# use gethostbyname() since getaddrinfo() does not indicate if it
# followed a CNAME. If we followed a CNAME, update what we actually
# query
( $t_name, $t_alias, undef, undef, undef ) = gethostbyname( $name );
if (   ( $t_alias         )
    && ( $name ne $t_name )) {
  my @aliases = $t_alias->split( q/ / );
  @aliases->push( $t_name );
  for ( my $i = 0; $i < scalar @aliases -1; $i++ ) {
    say "$aliases[$i] is an alias for $aliases[$i+1].";
  }
  $name = $t_name;
}

my ( $err, @res ) = getaddrinfo ( $name, "", { socktype => SOCK_RAW,
                                               flags    => AI_CANONNAME } );
if ( $err ) {
  warn qq{Host $name not found: NXDOMAIN/SERVFAIL\n};
  exit EX_ERROR;
}

while ( my $ai = @res->shift ) {
  if ( $is_ipaddress ) {
    my ( $reverse, $tld ) = ( undef, undef );
    my ( $err, $ptr_name ) = getnameinfo ( $ai->{addr} );
    given ( $ai->{family} ) {
      when ( AF_INET ) {
        $reverse = reverse_ipv4( $name );
        $tld = q/in-addr.arpa/;
      }
      when ( AF_INET6 ) {
        $reverse = reverse_ipv6( $name );
        $tld = q/ip6.arpa/;
      }
      default {
        warn qq{Unrecognized IP protocol version.\n};
        exit EX_ERROR;
      }
    }
    # we get our question as result if nothing was found
    if ( $name ne $ptr_name ) {
      say "$reverse.$tld domain name pointer $ptr_name.";
    }
    else {
      warn qq{Host $reverse.$tld not found: NXDOMAIN/SERVFAIL\n};
      exit EX_ERROR;
    }
  }
  else {
    my ( $family ) = ( undef );
    my ( $err, $ipaddr ) = getnameinfo ( $ai->{addr}, NI_NUMERICHOST );

    # first result should have canonname set, after which we are good.
    # If things go shitfaced, fallback to $name
    $canon = $ai->{canonname} if $ai->{canonname};
    $canon = $canon // $name;

    given ( $ai->{family} ) {
      when ( AF_INET ) {
        $family = q/IPv4/;
      }
      when ( AF_INET6 ) {
        $family = q/IPv6/;
      }
      default {
        warn qq{Unrecognized IP protocol version.\n};
        exit EX_ERROR;
      }
    }
    say "$canon has $family address $ipaddr";
  }
}
exit EX_OK;
